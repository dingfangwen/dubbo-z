package com.zebra;import java.io.File;import java.net.InetAddress;import java.util.HashMap;import java.util.List;import java.util.Map;import java.util.concurrent.BlockingQueue;import java.util.concurrent.CountDownLatch;import java.util.concurrent.ExecutorService;import java.util.concurrent.Executors;import java.util.concurrent.LinkedBlockingQueue;import com.zebra.domain.Engin2Info;import org.apache.log4j.Logger;import org.apache.zookeeper.AsyncCallback.VoidCallback;import org.apache.zookeeper.CreateMode;import org.apache.zookeeper.WatchedEvent;import org.apache.zookeeper.Watcher;import org.apache.zookeeper.Watcher.Event.KeeperState;import org.apache.zookeeper.ZooDefs.Ids;import org.apache.zookeeper.ZooKeeper;public class Global {	private static Logger logger = Logger.getLogger(Global.class);	/**	 * 基础路径	 */	private static String baseDir = null;	/**	 * 阻塞队列	 */	private static final BlockingQueue<File> fileQueue = new LinkedBlockingQueue();		/**	 * 线程池	 */	private static final ExecutorService File2BlockService = Executors.newCachedThreadPool();		/**	 * 阻塞大小	 */	private static int blockSize = 0;		/**	 * 线程池	 */	private static final ExecutorService Block2LineService = Executors.newCachedThreadPool();		/**	 * 阻塞队列	 */	private static final BlockingQueue<String> lineQueue = new LinkedBlockingQueue();	/**	 * �������������Ϣ��map	 */	private static final Map<String,Engin2Info> e2Map = new HashMap();		public static void init(){		try {			//1.初始化zookeeper			final CountDownLatch cdl1 = new CountDownLatch(1);			ZooKeeper zk = new ZooKeeper("192.168.242.133:2181,192.168.242.135:2181,192.168.242.138:2181",5000				,new Watcher(){					@Override					public void process(WatchedEvent event) {						if(event.getState() == KeeperState.SyncConnected){							cdl1.countDown();						}					}			});			cdl1.await();						//2.获取/zebra/engin1中的信息 -- baseDir blockSize			Map<String,String> e1_data_map = syncGetData(zk, "/zebra/engin1");			Global.baseDir = e1_data_map.get("baseDir");			Global.blockSize = Integer.parseInt(e1_data_map.get("blockSize"));						//3.获取/zebra/engin2的所有孩子  并获取当前孩子的二级引擎信息			List<String> e2Name_list = zk.getChildren("/zebra/engin2", false);			for(int i=1;i<=e2Name_list.size();i++){				String e2Name = e2Name_list.get(i-1);				Map<String,String> e2Child_data_map = syncGetData(zk, "/zebra/engin2/"+e2Name);				String ip = e2Child_data_map.get("ip");				int port = Integer.parseInt(e2Child_data_map.get("port"));				Engin2Info e2info = new Engin2Info(ip, port);				e2Map.put(i+"", e2info);			}			//4.Zaire/zebra/engin1下创建顺序的临时节点 表明自己上线,其中保存当前信息的ip			String ip = InetAddress.getLocalHost().getHostAddress();			zk.create("/zebra/engin1/engin1_", ("ip="+ip).getBytes(), Ids.OPEN_ACL_UNSAFE, CreateMode.EPHEMERAL_SEQUENTIAL);						logger.info("初始化完成");		} catch (Exception e) {			e.printStackTrace();			throw new RuntimeException(e);		}	}	/**	 * 获取节点的数据信息	 * @param zk	 * @param path	 * @return	 * @throws Exception	 */	private static Map<String,String> syncGetData(ZooKeeper zk,String path) throws Exception{		final CountDownLatch cdl = new CountDownLatch(1);		//刷新当前的		zk.sync(path, new VoidCallback() {			@Override			public void processResult(int rc, String path, Object ctx) {				cdl.countDown();			}		}, null);		cdl.await();		String data = new String(zk.getData(path, false, null));			Map<String,String> retu_map = new HashMap<String, String>();		String [] kvs = data.split(",");		for(String kv : kvs){			retu_map.put(kv.split("=")[0], kv.split("=")[1]);		}				return retu_map;	}		public static Map<String, Engin2Info> getE2map() {		return e2Map;	}		public static String getBasedir() {		return baseDir;	}	public static BlockingQueue<File> getFilequeue() {		return fileQueue;	}	public static ExecutorService getFile2blockservice() {		return File2BlockService;	}	public static int getBlocksize() {		return blockSize;	}	public static ExecutorService getBlock2lineservice() {		return Block2LineService;	}	public static BlockingQueue<String> getLinequeue() {		return lineQueue;	}	}